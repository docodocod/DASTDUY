## 요구 사항 확인

### 소프트웨어 생명주기
> 폭포수 타입 / 프로토 타입 / 나선형 / 애자일
---
### 나선형 모델 절차
> 계획 및 정의 / 위험 분석/ 개발 / 고객평가
---
### 객체 지향 기법
> 캡슐화 / 상속성 / 다형성 / 추상화 / 정보 은닉 /관계성
---
### 럼바우의 객체 지향 분석 절차
> 객체 모델링 / 동적 모델링 / 기능 모델링
---
### COCOMO의 소프트웨어 개발 유형
> Organic Mode / Semi-Detached Mode / Embedded Mode
---
### 소프트웨어 아키텍처 4+1 뷰
> 유스케이스 뷰 / 논리 뷰 / 프로세스 뷰 / 구현 뷰 /배포 뷰
---
### 아키텍쳐 비용 평가모델 종류
> SAAM / ATAM / CBAM / ADR / ARID
---
### 디자인 패턴 구성요소
> 패턴이름 / 문제 / 솔루션 / 사례 / 결과 / 샘플코드
---
### 목적에 따른 디자인 패턴 유형
> 생성 / 구조 / 행위
---
### 목적에 따른 디자인 패턴 종류
- 생성 패턴
> 빌더 / 프로토 타입 / 팩토리 메서드 / 앱스트랙트 팩토리 / 싱글톤

- 구조 패턴
> 브리지 / 데코레이터 / 퍼사이드 / 플라이 웨이트 / 프록시 / 컴포지트 / 어댑터

- 행위 패턴
> 미디에이터 / 인터프리터 /이터레이터 / 템플릿 메서드 / 옵저버 / 스테이트 / 비지터 / 커맨드 / 스트레티지 / 메멘토 / 체인 오브 리스판서빌리티)
---
### 요구사항 개발 프로세스
> 요구사항 도출 / 요구사항 분석 / 요구사항 명세 / 요구사항 확인 및 검증
---
## 화면 설계

### UI 유형
> CLI / GUI / NUI / OUI
---
### UI 설계 원칙
> 직관성 / 유효성 / 학습성 / 유연성
---
### UI 품질 요구사항
> 기능성 / 신뢰성 / 사용성 / 효율성 / 유지보수성 / 이식성
---
### UI 화면 설계 구분
> 와이어 프레임 / 스토리보드 / 프로토타입
---
### UML의 특징
> 가시화 / 구축 / 명세화 / 문서화 언어
---
### UML의 구성요소
> 사물 / 관계 / 다이어그램
---
### 구조적 다이어그램 / 정적 다이어그램
> 클래스 / 객체 / 컴포넌트 / 배치 / 복합체 구조 / 패키지
---
### 행위적 다이어그램 / 동적 다이어그램
> 유스케이스 / 시퀀스 / 커뮤니케이션 / 상태 / 활동 / 타이밍
---
## 데이터 입출력 구현

### 데이터 모델링 절차
> 요구조건 분석 / 개념적 설계 / 논리적 설계 / 물리적 설계
---
### 관계 대수와 관계 해석
> 관계 대수는 절차적 언어 / 관계 해석은 비절차적 언어
---
### 일반 집합 연산
> 합집합 / 교집합 / 차집합 / 카티션 프로덕트
---
### 순수 관계 연산자
> 셀렉트 / 프로젝트 / 조인 / 디비전
---
### 논리 데이터 모델링 속성
> 개체 / 속성 / 관계
---
### 이상현상
> 삽입이상 / 삭제이상 / 갱신이상
---
### DB 정규화 단계
> 원자화->부분함수 종속 제거->이행함수 종속 제거->결정자 함수 종속제거->다치 종속 제거->조인 종속 제거
---
### DB 무결성 종류
> 개체 무결성 / 참조 무결성 / 속성 무결성 / 사용자 무결성 / 키 무결성
---
### 파티셔닝의 종류
> 레인지 파티셔닝 / 해시 파티셔닝 / 리스트 파티셔닝 / 컴포지트 파티셔닝 / 라운드 로빈 파티셔닝
---
### NoSQL의 유형
> Key-value store / Column Family Data store / Dcoument Store/ Graph Store
---
### 데이터 마이닝 주요 기법
> 분류 규칙/연관 규칙/연속 규칙/데이터 군집화
---
