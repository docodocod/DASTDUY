### 1. RDS 특징
>관계형 데이터 베이스 조작 및 관리를 수행하는 완전 관리형 웹서비스
automated backups와 DB snapshot으로 백업 기능
AWS IAM을 사용하여 사용자를 제어할 수 있음.

**장점**<br>
서버와 분리되어 있기 때문에 보안성 ⬆️<br>
서버가 다운 될 경우 DB도 영향을 받을 경우 ⬇️<br>
스토리지의 크기를 쉽게 확장할 수 있다.<br>
**단점**<br>
스토리지 용량을 축소하려면 재구성<br>
비용문제 : RDS와 EC2의 비슷한 스토리지를 비교할 경우 RDS가 EC2보다 약 40~68% 정도 비싸다.<Br>
서버에 직접 접속이 불가능하여 로그 확인이 어려움. Cloud Watch를 사용할 수 있지만 비용이 발생<br>
---
### 2.Restful Api 특징

Representational State Transfer
>자원의 이름을 구분하여 자원의 상태를 주고받음.
HTTP URI 를 통해 자원 명시, HTTP Method(POST, GET, PUT, DELETE)를 사용하여 CRUD Operation 적용

**REST의 3가지 요소** <br>
자원(Resource) : HTTP URI<br>
자원에 대한 행위(Verb) : HTTP Method<br>
자원에 대한 행위의 내용(Representations) : HTTP Message Pay load<br>

**Rest의 특징**<Br>
Server-Client(서버-클라이언트 구조) 자원이 있는 쪽 : Server<br>
자원 요청하는 쪽 : Client Client는 사용자 인증이나 context(세션, 로그인 정보)등을 직접 관리, 책임 역할을 구분하여 상호간의 의존성 줄임.<br>
Stateless(무상태) Http 프로토콜이 Stateless 임 → Rest 역시 무상태성을 가짐. Client의 context를 Server에 저장하지 않음(ex. 세션, 쿠키 등)<br>
Cacheable(캐시 처리 가능) 웹 표준 HTTP 프로토콜을 그대로 사용, 웹에서 사용하는 기존 인프라 활용 → HTTP가 가진 캐싱 기능 적용 가능, Last-Modified Tag 또는 E-Tag를 이용해 캐싱 구현 대량의 요청 효율적 처리
Layered System(계층화) Rest Server는 다중 계층으로 구성될 수 있음 보안, 로드밸런싱, 암호화 등을 위한 계층 추가하여 구조 변경 가능 Proxy, Gateway와 같은 네트워크 기반의 중간매체 사용 가능 하지만 Client는 Server와 직접 통신하는지, 중간 서버와 통신하는지 알 수 없음.
Uniform Interface(인터페이스 일관성) URI로 지정한 Resource에 대한 요청을 통일, 한정적으로 수행하는 아키택쳐 스타일 의미 HTTP 표준 프로토콜 따르는 모든 플랫폼에서 사용 가능 → 특정 언어나 기술에 종속되지 않음
Self-Descriptiveness(자체 표현) 요청 메시지만 보고도 쉽게 이해할 수 있음.<br>

**장점**<br>
HTTP 프로토콜 준수하기 때문에 HTTP 프로토콜을 따르는 모든 곳에서 사용 가능<br>
HTTP 프로토콜 인프라를 사용하기 때문에 REST API 사용을 위한 별도의 인프라 구축 필요 없음<br>
REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도를 정확히 파악 할 수 있으며 여러가지 서비스 디자인에서 발생할 수 있는 문제를 최소화함.<br>

**단점**<br>
사용 가능한 Method가 4가지 밖에 없다.(형태가 제한적)<br>
구형 브라우저에서 호환되지 않아 지원되지 않는 동작이 있다.(익스플로어)<br>
---
### 3.세션과 쿠키
**HTTP 특징**<br>
Connection 프로토콜(비연결지향) : 클라이언트가 서버에 요청을 하면 응답을 보낸 후 연결을 끊는 처리방식<br>
Stateless 프로토콜(상태정보 유지 안함) : 클라이언트의 상태 정보를 가지지 않는 서버 처리 방식<br>
⇒ Stateful의 경우에 대처하기 위해 쿠키와 세션을 사용, 둘의 가장 큰 차이점은 상태 정보 저장 위치<br>

**세션 vs 쿠키**<br>
세션은 보안이 쿠키보다 좋으나 서버에 저장돼 서버 자원을 사용하기 때문에 사용자가 많을 경우 소모되는 자원이 많음. 자원 관리 차원에서 쿠키와 세션을 적절히 병행 사용하며 서버 자원의 낭비를 방지하여 웹사이트 속도를 높일 수 있음.

**세션 특징**<br>
세션 : 브라우저를 닫아 서버와의 연결을 끝내는 시점<br>
방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그걸 세션이라고 함.<br>
웹서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장<br>
웹 서버에 저장되는 쿠키(=세션 쿠키)<br>
브라우저를 닫거나 서버에서 세션을 삭제할 때 삭제 되므로 쿠키보다 비교적 보안이 좋음<br>
저장 데이터에 제한이 없음.(서버 용량이 허용하는 한)<br>
각 클라이언트 고유 Session ID 부여<br>

**동작 순서**<br>
클라이언트가 페이지를 요청<br>
=>서버는 클라이언트의 Request-Header 필드인 Cookie를 확인<br>
=>클라이언트가 해당 session-id를 보냈는지 확인<br>
=>session-id가 존재하지 않는다면 서버는 session-id를 생성해 클라이언트에게 돌려줌<br>
=>서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장<br>
=>클라이언트는 재접속 시, 이 쿠키를 이용하여 session-id 값을 서버에 전달<br>

**쿠키 특징**<br>

HTTP의 일종으로 사용자가 어떤 웹사이트에 방문할 경우 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 정보 기록 파일<br>
HTTP에서 클라이언트의 상태 정보를 클라이언트 PC에 저장하였다가 필요시 정보를 참조, 재사용 가능<br>
이름, 값, 만료일(저장기간 설정), 경로 정보로 구성<br>
클라이언트에 총 300개의 쿠키를 저장할 수 있음<br>
하나의 도메인 당 20개의 쿠키를 가질 수 있음<br>
하나의 쿠키는 4KB까지 저장 가능<br>

**쿠키의 동작 순서**<br>
클라이언트가 페이지를 요청<br>
=>웹서버는 쿠키를 생성<br>
=>생성한 쿠키에 정보를 담아 http 화면을 돌려줄때 같이 클라이언트에게 돌려줌<br>
=>넘겨 받은 쿠키는 클라이언트가 가지고 있다가(로컬 PC에 저장) 다시 서버에 요청할때 요청과 함께 쿠키 전송<br>
=>동일 사이트 재방문시 클라이언트의 PC에 해당 쿠키가 있는 경우, 요청 페이지와 함께 쿠키 전송
---
### 4.Status Code 200번대
200 : OK 요청 성공적 수행<br>
201 : Created (요청 성공적 수행+ 결과로 새로운 리소스 생성 POST, PUT) ex. 회원 가입<br>
204 : No Content (요청 성공적 수행 + 결과로 리소스 삭제 완료) ex. 게시글 삭제<br>
---
### 5.Status Code 400번대
400 : Bad Request (사용자의 잘못된 요청을 처리할 수 없음) ex. Number로 응답해야하는 값을 string으로 보냄.<br>
401 : Unauthorized (인증이 필요한 페이지 요청) ex. 로그인이 필요한 페이지에 접근<br>
403 : Forbidden (접근 권한 없음) ex. 관리자의 권한이 필요한 페이지에 접근<br>
404 : Not found (요청한 페이지-리소스 없음) ex. 경로 잘못되거나 자원 없는 경우<br>
405 : Method not allowed (허용되지 않는 HTTP Method를 사용한 경우)<br>
408 : Request Timeout (요청 시간 초과)<br>
---
### 6.Status Code 500번대
500 : Internal Server Error (내부 서버 오류)<br>
502 : Bad Gateway(게이트웨이 오류)<br>
---
### 7.쓰로톨링과 디바운싱
DOM 이벤트를 기반으로 실행하는 자바스크립트를 성능상의 이유로 제어하는 방법<br>

**Debounce**<br>
연이어 호출되는 함수들 중 마지막 함수만 호출되도록 하는 것
검색어를 입력할때 엔터 없이도 결과를 즉시 보여주려면 항상 input 이벤트가 대기하고 있어야함.<br>
→ 한글자 칠때마다 ajax 요청 실행 : ㄱ, 가, 감 ⇒ 이렇게 요청이 여러번 보내지게 되면 비용 문제 발생(ex. 구글지도 api)<br>
방법 타자를 칠때 setTimeout으로 타이머 설정 ex. 1초동안 다른 입력 없으면 입력 끝난 것으로 간주, 지정한 시간 동안 마지막 한번 호출<br>
**Throttling**<br>
마지막 함수가 호출된 후 일정 시간이 지나기 전까지 다시 호출 되지 않도록 하는 것<br>
스크롤 올리거나 내릴때 scroll 이벤트가 계속해서 발생하면 버퍼링이 발생할 수 있기 때문에 몇 초에 한번, 밀리초에 한번씩만 실행되게 제한하는 것<br>
---
### 8.도커 특징

컨테이너 기반의 오픈소스 가상화 플랫폼<br>
애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼<br>
컨테이너 환경에서 독립적으로 애플리케이션을 실행할 수 있도록 컨테이너를 만들고 관리하는 것을 도와주는 도구<br>
도커를 실행하면 독립적 환경에서 일관된 결과를 보여줌<br>

**장점**<br>
쉽고 빠른 실행 환경 구축<br>
가볍고 빠른 실행 속도→ vm의 경우 OS를 재구동 해야하므로 시작 자체가 무거움, 도커 컨테이너는 상대적으로 경량이기 때문에 시작이 빠름<br>
하드웨어 자원 절감 → 컨테이너의 크기가 매우 작고 하나의 물리적 서버에 다수의 컨테이너를 가동시킬 수 있음. 비용절감 효과가 큼<br>
공유 환경 제공 → Docker Hub를 통해 전세계의 개발자의 결과물을 공유할 수 있음. 이미지를 내려받기만 하면 됨<br>
쉬운 배포 → 프로그램 개발이 완료되면 개발했던 환경을 그대로 배포할 수 있음.<br>
**단점**<br>
개발 초기의 오버 헤드 → 초반 환경 설정시 시행착오를 겪을 확률 높음, 소규모 프로젝트라면 도커 사용 제고 해볼것<br>
리눅스 친화적(플랫폼 의존적)<br>
**컨테이너**<br>
격리된 공간에서 프로세스가 동작하는 기술
---